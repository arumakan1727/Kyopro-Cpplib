{
	"Algorithm/pow-doubling.hpp": {
		"scope": "cpp",
		"prefix": "pow-doubling",
		"body": [
			"template \u003cclass Integer\u003e",
			"Integer pow(const Integer\u0026 n, const i64 expv) {",
			"    Integer ret = 1, square = n;",
			"    for (u64 p = std::abs(expv); p; p \u003e\u003e= 1) {",
			"        if (p \u0026 1) ret *= square;",
			"        square *= square;",
			"    }",
			"    return (expv \u003c 0) ? (1 / ret) : ret;",
			"}"
		]
	},
	"Disjoint-Set/union-find.hpp": {
		"scope": "cpp",
		"prefix": "union-find",
		"body": [
			"class UnionFind {",
			"private:",
			"    mutable std::vector\u003cint\u003e p;",
			"",
			"public:",
			"    UnionFind() = default;",
			"",
			"    explicit UnionFind(size_t n)",
			"        : p(n, -1) {}",
			"",
			"    void unite(int x, int y) {",
			"        x = root(x), y = root(y);",
			"        if (x == y) return;",
			"        if (p[y] \u003c p[x]) std::swap(x, y);",
			"        p[x] += p[y];",
			"        p[y] = x;",
			"    }",
			"",
			"    int root(int x) const {",
			"        if (p[x] \u003c 0) return x;",
			"        return p[x] = root(p[x]);",
			"    }",
			"",
			"    bool same(int x, int y) const { return root(x) == root(y); }",
			"",
			"    int size(int x) const { return -p[root(x)]; }",
			"};"
		]
	},
	"IO/container-io.hpp": {
		"scope": "cpp",
		"prefix": "container-io",
		"body": [
			"template \u003cclass Container,",
			"          class Value = typename Container::value_type,",
			"          std::enable_if_t\u003c!std::is_same\u003cContainer, std::string\u003e::value, std::nullptr_t\u003e = nullptr\u003e",
			"std::istream\u0026 operator\u003e\u003e(std::istream\u0026 is, Container\u0026 v) {",
			"    for (auto\u0026 e : v) is \u003e\u003e e;",
			"    return is;",
			"}",
			"",
			"template \u003cclass Container,",
			"          class Value = typename Container::value_type,",
			"          std::enable_if_t\u003c!std::is_same\u003cContainer, std::string\u003e::value, std::nullptr_t\u003e = nullptr\u003e",
			"std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const Container\u0026 v) {",
			"    for (auto it = std::begin(v); it != std::end(v); ++it) os \u003c\u003c \" \" + (it == std::begin(v)) \u003c\u003c *it;",
			"    return os;",
			"}"
		]
	},
	"IO/io-setup.hpp": {
		"scope": "cpp",
		"prefix": "io-setup",
		"body": [
			"void ioSetup() {",
			"    std::cin.tie(nullptr);",
			"    std::ios_base::sync_with_stdio(false);",
			"    std::cout \u003c\u003c std::fixed \u003c\u003c std::setprecision(11);",
			"    std::cerr \u003c\u003c std::fixed \u003c\u003c std::setprecision(11);",
			"    std::clog \u003c\u003c std::fixed \u003c\u003c std::setprecision(11);",
			"}"
		]
	},
	"IO/join-into-ostream.hpp": {
		"scope": "cpp",
		"prefix": "join-into-ostream",
		"body": [
			"template \u003cclass InputItr\u003e",
			"void join(std::ostream\u0026 os, InputItr begin, InputItr end, const char* delim, const char* last = \"\\n\") {",
			"    const char* tmp[] = {delim, \"\"};",
			"    for (auto it = begin; it != end; ++it) os \u003c\u003c tmp[it == begin] \u003c\u003c *it;",
			"    os \u003c\u003c last;",
			"}"
		]
	},
	"IO/println.hpp": {
		"scope": "cpp",
		"prefix": "println",
		"body": [
			"inline void println() {",
			"    std::cout \u003c\u003c '\\n';",
			"}",
			"template \u003cclass Head, class... Tail\u003e",
			"inline void println(Head\u0026\u0026 head, Tail\u0026\u0026... tail) {",
			"    std::cout \u003c\u003c head \u003c\u003c \" \" + (!sizeof...(tail));",
			"    println(std::forward\u003cTail\u003e(tail)...);",
			"}"
		]
	},
	"IO/tuple-print.hpp": {
		"scope": "cpp",
		"prefix": "tuple-print",
		"body": [
			"template \u003cclass Tuple, size_t... I\u003e",
			"std::array\u003cint, sizeof...(I)\u003e tuple_print_impl(std::ostream\u0026 os, Tuple\u0026\u0026 t, std::index_sequence\u003cI...\u003e) {",
			"    return {{(void(os \u003c\u003c (I == 0 ? \"\" : \", \") \u003c\u003c std::get\u003cI\u003e(t)), 0)...}};",
			"}",
			"template \u003cclass Tuple, class Value = typename std::tuple_element_t\u003c0, Tuple\u003e\u003e",
			"std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, Tuple\u0026\u0026 t) {",
			"    os \u003c\u003c '{';",
			"    tuple_print_impl(os, std::forward\u003cTuple\u003e(t), std::make_index_sequence\u003cstd::tuple_size\u003cstd::decay_t\u003cTuple\u003e\u003e::value\u003e{});",
			"    return os \u003c\u003c '}';",
			"}"
		]
	},
	"IO/var-declaration-with-input.hpp": {
		"scope": "cpp",
		"prefix": "var-declaration-with-input",
		"body": [
			"template \u003cclass T\u003e",
			"std::istream\u0026 operator,(std::istream\u0026 is, T\u0026 rhs) {",
			"    return is \u003e\u003e rhs;",
			"}",
			"",
			"#define var(type, ...) \\",
			"    type __VA_ARGS__;  \\",
			"    std::cin \u003e\u003e __VA_ARGS__"
		]
	},
	"Modulo/compile-time-mod-holder.hpp": {
		"scope": "cpp",
		"prefix": "compile-time-mod-holder",
		"body": [
			"template \u003ci64 Mod\u003e",
			"struct CompileTimeModHolder {",
			"    static constexpr i64 mod = Mod;",
			"};"
		]
	},
	"Modulo/mod-int.hpp": {
		"scope": "cpp",
		"prefix": "mod-int",
		"body": [
			"template \u003cclass ModHolder\u003e",
			"class ModInt {",
			"private:",
			"    i64 value;",
			"",
			"public:",
			"    constexpr ModInt()",
			"        : value(0) {}",
			"    constexpr ModInt(i64 v)",
			"        : value(ModInt::normalized(v)) {}",
			"",
			"    static constexpr i64 mod() { return ModHolder::mod; }",
			"",
			"    template \u003cclass T\u003e",
			"    constexpr explicit operator T() const {",
			"        return static_cast\u003cT\u003e(value);",
			"    }",
			"    constexpr ModInt\u0026 operator+=(const ModInt\u0026 rhs) {",
			"        if ((value += rhs.value) \u003e= mod()) value -= mod();",
			"        return *this;",
			"    }",
			"    constexpr ModInt\u0026 operator-=(const ModInt\u0026 rhs) {",
			"        if ((value -= rhs.value) \u003c 0) value += mod();",
			"        return *this;",
			"    }",
			"    constexpr ModInt\u0026 operator*=(const ModInt\u0026 rhs) {",
			"        (value *= rhs.value) %= mod();",
			"        return *this;",
			"    }",
			"    constexpr ModInt\u0026 operator/=(const ModInt\u0026 rhs) { return *this *= rhs.inv(); }",
			"",
			"    constexpr const ModInt inv() const { return ModInt(ModInt::inverse(value, mod())); }",
			"",
			"    constexpr const ModInt operator-() const { return ModInt(-value); }",
			"",
			"    constexpr bool operator==(const ModInt\u0026 rhs) const { return value == rhs.value; }",
			"    constexpr bool operator!=(const ModInt\u0026 rhs) const { return !(*this == rhs); }",
			"",
			"    friend constexpr const ModInt operator+(const ModInt\u0026 lhs, const ModInt\u0026 rhs) { return ModInt(lhs) += rhs; }",
			"    friend constexpr const ModInt operator-(const ModInt\u0026 lhs, const ModInt\u0026 rhs) { return ModInt(lhs) -= rhs; }",
			"    friend constexpr const ModInt operator*(const ModInt\u0026 lhs, const ModInt\u0026 rhs) { return ModInt(lhs) *= rhs; }",
			"    friend constexpr const ModInt operator/(const ModInt\u0026 lhs, const ModInt\u0026 rhs) { return ModInt(lhs) /= rhs; }",
			"",
			"    friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const ModInt\u0026 x) { return os \u003c\u003c x.value; }",
			"",
			"    friend std::istream\u0026 operator\u003e\u003e(std::istream\u0026 is, ModInt\u0026 x) {",
			"        is \u003e\u003e x.value;",
			"        x.value = ModInt::normalized(x.value);",
			"        return is;",
			"    }",
			"",
			"private:",
			"    static constexpr i64 normalized(i64 n) {",
			"        n = (-mod() \u003c= n \u0026\u0026 n \u003c mod() ? n : n % mod());",
			"        if (n \u003c 0) n += mod();",
			"        return n;",
			"    }",
			"",
			"    static constexpr i64 inverse(i64 a, i64 m) {",
			"        i64 u = 0, v = 1;",
			"        while (a != 0) {",
			"            const auto t = m / a;",
			"            m -= t * a, std::swap(m, a);",
			"            u -= t * v, std::swap(u, v);",
			"        }",
			"        assert(m == 1);",
			"        return u;",
			"    }",
			"};"
		]
	},
	"Modulo/runtime-mod-holder.hpp": {
		"scope": "cpp",
		"prefix": "runtime-mod-holder",
		"body": [
			"struct RuntimeModHolder {",
			"    static i64 mod;",
			"};",
			"i64 RuntimeModHolder::mod;"
		]
	},
	"Util/all-macro.hpp": {
		"scope": "cpp",
		"prefix": "all-macro",
		"body": [
			"#define all(x) std::begin(x), std::end(x)",
			"#define rall(x) std::rbegin(x), std::rend(x)"
		]
	},
	"Util/bye.hpp": {
		"scope": "cpp",
		"prefix": "bye",
		"body": [
			"template \u003cclass T\u003e",
			"inline void bye(const T\u0026 x) {",
			"    std::cout \u003c\u003c x \u003c\u003c '\\n', exit(0);",
			"}"
		]
	},
	"Util/chminmax.hpp": {
		"scope": "cpp",
		"prefix": "chminmax",
		"body": [
			"template \u003cclass T, class U\u003e",
			"inline bool chmin(T\u0026 a, const U\u0026 b) {",
			"    return b \u003c a \u0026\u0026 (a = b, true);",
			"}",
			"",
			"template \u003cclass T, class U\u003e",
			"inline bool chmax(T\u0026 a, const U\u0026 b) {",
			"    return b \u003e a \u0026\u0026 (a = b, true);",
			"}"
		]
	},
	"Util/div-ceil.hpp": {
		"scope": "cpp",
		"prefix": "div-ceil",
		"body": [
			"inline int64_t divceil(int64_t a, int64_t b) {",
			"    return (a + b - 1) / b;",
			"}"
		]
	},
	"Util/int-alias.hpp": {
		"scope": "cpp",
		"prefix": "int-alias",
		"body": [
			"using i64 = std::int64_t;",
			"using u64 = std::uint64_t;",
			"using usize = std::size_t;"
		]
	},
	"Util/int-infinity.hpp": {
		"scope": "cpp",
		"prefix": "int-infinity",
		"body": [
			"constexpr int32_t INF = 0x3f3f3f3f;",
			"constexpr int64_t LINF = 0x3f3f3f3f3f3f3f3fLL;"
		]
	},
	"Util/is-within-range.hpp": {
		"scope": "cpp",
		"prefix": "is-within-range",
		"body": [
			"template \u003cclass Value, class ValueBegin, class ValueEnd\u003e",
			"inline bool within(const Value\u0026 v, const ValueBegin\u0026 begin, const ValueEnd\u0026 end) {",
			"    return begin \u003c= v \u0026\u0026 v \u003c end;",
			"}"
		]
	},
	"Util/makeVec.hpp": {
		"scope": "cpp",
		"prefix": "makeVec",
		"body": [
			"template \u003cclass T\u003e",
			"inline std::vector\u003cT\u003e makeVec(const T\u0026 initValue, size_t sz) {",
			"    return std::vector\u003cT\u003e(sz, initValue);",
			"}",
			"template \u003cclass T, class... Args\u003e",
			"inline auto makeVec(const T\u0026 initValue, size_t sz, Args... args) {",
			"    return std::vector\u003cdecltype(makeVec\u003cT\u003e(initValue, args...))\u003e(sz, makeVec\u003cT\u003e(initValue, args...));",
			"}"
		]
	},
	"Util/rep-macro.hpp": {
		"scope": "cpp",
		"prefix": "rep-macro",
		"body": [
			"#define rep(i, begin, end) for (int64_t i{begin}, i##_end{end}; i \u003c i##_end; ++i)",
			"#define repc(i, begin, last) for (int64_t i{begin}, i##_last{last}; i \u003c= i##_last; ++i)",
			"#define repr(i, begin, last) for (int64_t i{begin}, i##_last{last}; i \u003e= i##_last; --i)"
		]
	}
}