snippet doubling-pow "Algorithm/doubling-pow.hpp"
// doubling-pow {{{
template <class Integer>
constexpr Integer doublingPow(const Integer& n, const i64 expv) {
    Integer ret = 1, square = n;
    for (u64 p = std::abs(expv); p; p >>= 1) {
        if (p & 1) ret *= square;
        square *= square;
    }
    return (expv < 0) ? (1 / ret) : ret;
}
// }}}
endsnippet

snippet union-find "Disjoint-Set/union-find.hpp"
// union-find {{{
class UnionFind {
private:
    int n;
    mutable std::vector<int> p;

public:
    UnionFind() = default;

    explicit UnionFind(int n_)
        : n(n_)
        , p(n_, -1) {}

    int unite(int x, int y) {
        x = leader(x), y = leader(y);
        if (x == y) return x;
        if (p[y] < p[x]) std::swap(x, y);
        p[x] += p[y];
        p[y] = x;
        return x;
    }

    int leader(int x) const { return p[x] < 0 ? x : p[x] = leader(p[x]); }

    bool same(int x, int y) const { return leader(x) == leader(y); }

    int size(int x) const { return -p[leader(x)]; }

    std::vector<std::vector<int>> groups() const {
        std::vector<int> leaderBuf(n), groupSize(n);
        for (int i = 0; i < n; i++) ++groupSize[leaderBuf[i] = leader(i)];

        std::vector<std::vector<int>> result(n);
        for (int i = 0; i < n; i++) result[i].reserve(groupSize[i]);
        for (int i = 0; i < n; i++) result[leaderBuf[i]].push_back(i);
        result.erase(std::remove_if(result.begin(), result.end(), [](const std::vector<int>& v) { return v.empty(); }), result.end());
        return result;
    }
};
// }}}
endsnippet

snippet factorials "Combinatorics/factorials.hpp"
// factorials {{{
template <int Mod>
struct Factorials {
public:
    using value_type = StaticModInt<Mod>;
    static constexpr std::size_t MAX_N = std::min<std::size_t>(1e7, Mod) + 1;

private:
    mutable std::vector<value_type> m_fact, m_finv;

public:
    Factorials() {
        m_fact.reserve(MAX_N);
        m_finv.reserve(MAX_N);
        m_fact.resize(2, value_type::raw(1));   // m_fact[0] = m_fact[1] = 1
        m_finv.resize(2, value_type::raw(1));   // m_finv[0] = m_finv[1] = 1
    }

    void preCalc(std::size_t n) const {
        if (n < m_fact.size()) return;
        const std::size_t l = m_fact.size();
        const std::size_t r = n + 1;
        m_fact.resize(r), m_finv.resize(r);
        for (std::size_t i = l; i < r; ++i) m_fact[i] = m_fact[i - 1] * i;
        m_finv[r - 1] = m_fact[r - 1].inv();
        for (std::size_t i = r - 1; i > l; --i) m_finv[i - 1] = m_finv[i] * i;
    }

    const value_type fact(int i) const { return preCalc(i), m_fact[i]; }
    const value_type finv(int i) const { return preCalc(i), m_finv[i]; }

    const value_type C(int n, int r) const {
        if (r < 0 || n < r) return value_type::raw(0);
        return preCalc(n), m_fact[n] * m_finv[r] * m_finv[n - r];
    }

    const value_type P(int n, int r) const {
        if (r < 0 || n < r) return value_type::raw(0);
        return preCalc(n), m_fact[n] * m_finv[n - r];
    }

    const value_type H(int n, int r) const {
        if (n < 0 || r < 0) return value_type::raw(0);
        if (n == 0 && r == 0) return value_type::raw(1);
        return C(n + r - 1, r);
    }
};
// }}}
endsnippet

snippet mod-int "Modulo/mod-int.hpp"
// mod-int {{{
namespace impl {

template <class ModHolder>
class ModInt {
private:
    int64_t value;

public:
    constexpr ModInt()
        : value(0) {}
    constexpr ModInt(int64_t v)
        : value(ModInt::normalized(v)) {}

    static constexpr ModInt raw(int64_t v) {
        ModInt ret;
        ret.value = v;
        return ret;
    }

    static constexpr ModInt nullopt() { return ModInt::raw(std::numeric_limits<int64_t>::min()); }

    constexpr bool isNull() const { return *this == ModInt::nullopt(); }

    static constexpr int64_t mod() { return ModHolder::mod; }

    static int64_t setMod(int64_t m) {
        assert(m >= 1);
        return ModHolder::mod = m;
    }

    template <class T>
    constexpr explicit operator T() const {
        return static_cast<T>(value);
    }
    constexpr ModInt& operator+=(const ModInt& rhs) {
        if ((value += rhs.value) >= mod()) value -= mod();
        return *this;
    }
    constexpr ModInt& operator-=(const ModInt& rhs) {
        if ((value -= rhs.value) < 0) value += mod();
        return *this;
    }
    constexpr ModInt& operator*=(const ModInt& rhs) {
        (value *= rhs.value) %= mod();
        return *this;
    }
    constexpr ModInt& operator/=(const ModInt& rhs) { return *this *= rhs.inv(); }
    constexpr const ModInt inv() const { return ModInt(ModInt::inverse(value, mod())); }
    constexpr const ModInt operator+() const { return *this; }
    constexpr const ModInt operator-() const { return ModInt(-value); }

    constexpr const ModInt pow(int64_t expv) const {
        int64_t ret = 1, square = value;
        for (uint64_t p = std::abs(expv); p; p >>= 1) {
            if (p & 1) (ret *= square) %= mod();
            (square *= square) %= mod();
        }
        return (expv < 0) ? (ModInt::raw(1) / ModInt::raw(ret)) : ModInt::raw(ret);
    }

    friend constexpr bool operator==(const ModInt& lhs, const ModInt& rhs) { return lhs.value == rhs.value; }
    friend constexpr bool operator!=(const ModInt& lhs, const ModInt& rhs) { return lhs.value != rhs.value; }
    friend constexpr const ModInt operator+(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) += rhs; }
    friend constexpr const ModInt operator-(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) -= rhs; }
    friend constexpr const ModInt operator*(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) *= rhs; }
    friend constexpr const ModInt operator/(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) /= rhs; }

    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) {
#ifdef LOCAL_DEBUG
        if (x.isNull()) return os << "{nullopt}";
#endif
        return os << x.value;
    }

    friend std::istream& operator>>(std::istream& is, ModInt& x) {
        is >> x.value;
        x.value = ModInt::normalized(x.value);
        return is;
    }

private:
    static constexpr int64_t normalized(int64_t n) {
        n = (-mod() <= n && n < mod() ? n : n % mod());
        if (n < 0) n += mod();
        return n;
    }

    static constexpr int64_t inverse(int64_t a, int64_t m) {
        int64_t u = 0, v = 1;
        while (a != 0) {
            const auto t = m / a;
            static_cast<void>(m -= t * a), std::swap(m, a);
            static_cast<void>(u -= t * v), std::swap(u, v);
        }
        assert(m == 1);
        return u;
    }
};

template <int64_t Mod>
struct StaticModHolder {
    static constexpr int64_t mod = Mod;
};

template <auto ID>
struct DynamicModHolder {
    static int64_t mod;
};
template <auto ID>
int64_t DynamicModHolder<ID>::mod;

}  // namespace impl

template <int64_t Mod>
using StaticModInt = impl::ModInt<impl::StaticModHolder<Mod>>;

using ModInt1000000007 = StaticModInt<int(1e9) + 7>;
using ModInt998244353 = StaticModInt<998244353>;

template <auto ID>
using DynamicModInt = impl::ModInt<impl::DynamicModHolder<ID>>;
// }}}
endsnippet

snippet enumerate-divisors "Number-Theory/enumerate-divisors.hpp"
// enumerate-divisors {{{
template <class Integer>
std::vector<Integer> enumerateDivisors(Integer n) {
    std::vector<Integer> divisors;
    Integer i;
    for (i = 1; i * i < n; ++i) {
        if (n % i == 0) divisors.push_back(i), divisors.push_back(n / i);
    }
    if (i * i == n) divisors.push_back(i);
    std::sort(divisors.begin(), divisors.end());
    return divisors;
}
// }}}
endsnippet

snippet eratosthenes-sieve "Number-Theory/eratosthenes-sieve.hpp"
// eratosthenes-sieve {{{
class EratosthenesSieve {
private:
    int m_size;
    std::vector<int> m_minFactor;

public:
    EratosthenesSieve() = default;

    // [0, n] の範囲で篩を構築する
    explicit EratosthenesSieve(int n_)
        : m_size(n_ + 1)
        , m_minFactor(m_size) {
        std::iota(m_minFactor.begin(), m_minFactor.end(), 0);
        for (int i = 2; i * i < m_size; ++i) {
            if (m_minFactor[i] < i) continue;
            for (int j = i * i; j < m_size; j += i) {
                if (m_minFactor[j] == j) m_minFactor[j] = i;
            }
        }
        m_minFactor[0] = -1;
        if (n_ >= 1) m_minFactor[1] = -1;
    }

    bool isPrime(int x) const {
        assert(0 <= x && x < m_size);
        return m_minFactor[x] == x;
    }

    int minFactor(int x) const {
        assert(0 <= x && x < m_size);
        return m_minFactor[x];
    }
};
// }}}
endsnippet

snippet extgcd "Number-Theory/extgcd.hpp"
// extgcd {{{
// ax + by = gcd(a, b) の整数解 (x, y) を求める
template <class T>
T extgcd(T a, T b, T& x, T& y) {
    T g = a;
    if (b != 0) {
        g = extgcd(b, a % b, y, x);
        y -= (a / b) * x;
    } else {
        x = 1;
        y = 0;
    }
    return g;
}
// }}}
endsnippet

snippet is-prime "Number-Theory/is-prime.hpp"
// is-prime {{{
constexpr bool isPrime(int64_t n) {
    if (n == 2) return true;
    if (n <= 1 || n % 2 == 0) return false;
    for (int64_t i = 3; i * i <= n; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}
// }}}
endsnippet

snippet prime-factorize "Number-Theory/prime-factorize.hpp"
// prime-factorize {{{
template <class Integer>
std::map<Integer, int> primeFactorize(Integer n) {
    std::map<Integer, int> res;
    for (Integer i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            ++res[i];
            n /= i;
        }
    }
    if (n != 1) res[n] = 1;
    return res;
}
// }}}
endsnippet

snippet totient-func "Number-Theory/totient-func.hpp"
// totient-func {{{
template <class Integer>
constexpr Integer totient(Integer n) {
    Integer ret = n;
    for (Integer i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            ret -= ret / i;
            while (n % i == 0) n /= i;
        }
    }
    if (n != 1) ret -= ret / n;
    return ret;
}
// }}}
endsnippet

snippet rabin-karp "String/rabin-karp.hpp"
// rabin-karp {{{
template <std::uint_fast64_t Base>
std::vector<std::size_t> rabinKarp(const RollingHash<Base>& s, const RollingHash<Base>& pattern) {
    const auto sLen = s.size();
    const auto patLen = pattern.size();

    std::vector<std::size_t> foundIndexes;
    foundIndexes.reserve(sLen);

    for (std::size_t i = 0; i + patLen <= sLen; ++i) {
        if (s.substr(i, patLen) == pattern.hash()) foundIndexes.emplace_back(i);
    }

    foundIndexes.shrink_to_fit();
    return foundIndexes;
}
// }}}
endsnippet

snippet rolling-hash "String/rolling-hash.hpp"
// rolling-hash {{{
template <std::uint_fast64_t Base>
class RollingHash {
public:
    using u64 = std::uint_fast64_t;
    using u128 = __uint128_t;
    static constexpr u64 MOD = (1uL << 61) - 1;
    static constexpr u64 BASE = Base;

private:
    std::vector<u64> m_hash;

public:
    RollingHash() = default;

    template <class InputIter>
    RollingHash(InputIter begin, InputIter end)
        : m_hash(std::distance(begin, end) + 1, 0) {
        if (powArray().empty()) {
            powArray().reserve(1e6);
            powArray().emplace_back(1);
        }
        growPowArray(m_hash.size());

        std::size_t i;
        InputIter itr;
        for (itr = begin, i = 0; itr != end; ++itr, ++i) {
            m_hash[i + 1] = add(mul(m_hash[i], BASE), *itr);
        }
    }

    // 文字列全体のハッシュ値
    u64 hash() const { return m_hash.back(); }

    // 半開区間 [l, r) のハッシュ値
    u64 rangeHash(std::size_t l, std::size_t r) const {
        assert(l < r && r < m_hash.size());
        return add(m_hash[r], MOD - mul(m_hash[l], powArray()[r - l]));
    }

    // rangeHash(begin, begin + length) と等価
    u64 substr(std::size_t begin, std::size_t length) const { return rangeHash(begin, begin + length); }

    // もとの文字列の長さ
    std::size_t size() const { return m_hash.size() - 1; }

    // 連結した文字列 (leftStr + rightStr) のハッシュ値
    static u64 concat(u64 leftHash, u64 rightHash, std::size_t rightLength) {
        growPowArray(rightLength);
        return add(mul(leftHash, powArray()[rightLength]), rightHash);
    }

private:
    static inline std::vector<u64>& powArray() {
        static std::vector<u64> p;
        return p;
    }

    static constexpr inline u64 add(u64 a, u64 b) noexcept {
        if ((a += b) >= MOD) a -= MOD;
        return a;
    }

    static constexpr inline u64 mul(u128 a, u128 b) noexcept {
        const auto c = a * b;
        return add(static_cast<u64>(c >> 61), static_cast<u64>(c & MOD));
    }

    static inline void growPowArray(std::size_t len) {
        ++len;
        while (powArray().size() < len) {
            powArray().emplace_back(mul(powArray().back(), BASE));
        }
    }
};
// }}}
endsnippet

snippet debug "Debug/debug.hpp"
// debug {{{
template <class A, class B>
std::ostream& operator<<(std::ostream& os, const std::pair<A, B>& t) {
    return os << '{' << std::get<0>(t) << ", " << std::get<1>(t) << '}';
}
template <class A, class B, class C>
std::ostream& operator<<(std::ostream& os, const std::tuple<A, B, C>& t) {
    return os << '{' << std::get<0>(t) << ", " << std::get<1>(t) << ", " << std::get<2>(t) << '}';
}

template <class T, std::enable_if_t<std::is_integral_v<T> && sizeof(T) == 4, std::nullptr_t> = nullptr>
constexpr T infinity() {
    return INF;
}

template <class T, std::enable_if_t<std::is_integral_v<T> && sizeof(T) == 8, std::nullptr_t> = nullptr>
constexpr T infinity() {
    return LINF;
}

#ifdef LOCAL_DEBUG

class Debug {
private:
    int w_ = 4;
    int valueOffset_ = 0;
    int indexOffset_ = 0;
    bool negativeValAsNull_ = true;
    static constexpr int32_t inf32_ = INF;
    static constexpr int64_t inf64_ = LINF;

public:
    std::ostream& os = std::cerr;

    Debug() = default;

    void line() const { os << "---------------------------------------------------\n"; }
    void flush() const { os << std::flush; }
    void w(int w) { w_ = w; }
    void valueOffset(int v) { valueOffset_ = v; }
    void indexOffset(int v) { indexOffset_ = v; }
    void negativeValAsNull(bool f) { negativeValAsNull_ = f; }

    template <class T>
    void show(const T& x) const {
        put(x), os << '\n';
    }

    template <class T, class U, class... Tail>
    void show(const T& x, const U& y, const Tail&... tail) const {
        put(x);
        os << ",  ";
        show(y, tail...);
    }

    template <class Arr>
    void showArray(const Arr& a) const {
        showArray(a, 0, a.size());
    }

    template <class Arr>
    void showArray(const Arr& a, size_t begin, size_t end) const {
        os << '\n';
        for (size_t i = begin; i < end; ++i) os << '[' << std::setw(w_) << (i + indexOffset_) << "] ";
        os << '\n';
        for (size_t i = begin; i < end; ++i) os << ' ' << std::setw(w_), put(a[i]), os << "  ";
        os << '\n';
    }

    template <class Table>
    void showTable(const Table& t) const {
        showTable(t, 0, t.size(), 0, t[0].size());
    }

    template <class Table>
    void showTable(const Table& t, size_t yBegin, size_t yEnd, size_t xBegin, size_t xEnd) const {
        os << '\n';
        os << std::string(1 + 2 + 1, ' ');
        for (size_t j = xBegin; j < xEnd; ++j) os << '[' << std::setw(w_) << (j + indexOffset_) << "] ";
        os << '\n';

        for (size_t i = yBegin; i < yEnd; ++i) {
            os << '[' << std::setw(2) << (i + indexOffset_) << "]";
            for (size_t j = xBegin; j < xEnd; ++j) os << ' ' << std::setw(w_), put(t[i][j]), os << "  ";
            os << '\n';
        }
    }

private:
    template <class T>
    void put(const T& x) const {
        if constexpr (std::is_same_v<T, char>) {
            os << '\'' << x << '\'';
        } else if constexpr (std::is_same_v<T, bool>) {
            os << std::setw(w_) << (x ? "1" : "0");
        } else if constexpr (std::is_integral_v<T>) {
            os << std::setw(w_) << convert(x);
        } else if constexpr (std::is_convertible_v<T, std::string_view>) {
            os << std::setw(w_) << std::quoted(x);
        } else {
            os << std::setw(w_) << x;
        }
    }

    template <class T>
    std::string convert(const T& x) const {
        if constexpr (std::is_signed_v<T>) {
            if (x <= -infinity<T>()) return "-INF";
            if (negativeValAsNull_ && x < 0) return "-";
        }
        if (x >= infinity<T>()) return "INF";
        return std::to_string(x + valueOffset_);
    }
};

#define dump(...)                                                                                    \
    debug.os << "line" << std::setw(3) << std::setfill('0') << __LINE__ << std::setfill(' ') << ": " \
             << "[" << #__VA_ARGS__ << "]: ",                                                        \
        debug.show(__VA_ARGS__)

#else

#define DEF_FUNC(funcName) \
    template <class... T>  \
    void funcName(T&&...) {}

struct Debug {
    DEF_FUNC(line)
    DEF_FUNC(flush)
    DEF_FUNC(w)
    DEF_FUNC(valueOffset)
    DEF_FUNC(indexOffset)
    DEF_FUNC(negativeValAsNull)
    DEF_FUNC(inf32)
    DEF_FUNC(inf64)
    DEF_FUNC(show)
    DEF_FUNC(showArray)
    DEF_FUNC(showTable)
};

#undef DEF_FUNC
#define dump(...) ((void)0)

#endif

Debug debug;
// }}}
endsnippet

snippet errln "Debug/errln.hpp"
// errln {{{
inline void eprintln() {
    std::clog << std::endl;
}
template <class Head, class... Tail>
inline void eprintln(Head&& head, Tail&&... tail) {
    std::clog << head << &" "[!sizeof...(tail)];
    eprintln(std::forward<Tail>(tail)...);
}

#ifdef LOCAL_DEBUG
#define errln(...) std::clog << __FILE__ << "(" << __LINE__ << ")[" << __func__ << "()]: ", eprintln(__VA_ARGS__)
#else
#define errln(...) ((void)0)
#endif
// }}}
endsnippet

snippet container-io "IO/container-io.hpp"
// container-io {{{
template <class Container, class = typename Container::value_type, std::enable_if_t<!std::is_same_v<Container, std::string>, std::nullptr_t> = nullptr>
std::istream& operator>>(std::istream& is, Container& v) {
    for (auto& e : v) is >> e;
    return is;
}

template <class Container, class = typename Container::value_type, std::enable_if_t<!std::is_same_v<Container, std::string>, std::nullptr_t> = nullptr>
std::ostream& operator<<(std::ostream& os, const Container& v) {
    for (auto it = std::begin(v); it != std::end(v); ++it) os << &" "[it == std::begin(v)] << *it;
    return os;
}
// }}}
endsnippet

snippet join-into-ostream "IO/join-into-ostream.hpp"
// join-into-ostream {{{
template <class InputItr>
void join(std::ostream& os, InputItr begin, InputItr end, const char* delim, const char* last = "\n") {
    const char* tmp[] = {delim, ""};
    for (auto it = begin; it != end; ++it) os << tmp[it == begin] << *it;
    os << last;
}
// }}}
endsnippet

snippet println "IO/println.hpp"
// println {{{
inline void println() {
    std::cout << '\n';
}
template <class Head, class... Tail>
inline void println(Head&& head, Tail&&... tail) {
    std::cout << head << &" "[!sizeof...(tail)];
    println(std::forward<Tail>(tail)...);
}
// }}}
endsnippet

snippet var-declaration-with-input "IO/var-declaration-with-input.hpp"
// var-declaration-with-input {{{
template <class T>
std::istream& operator,(std::istream& is, T& rhs) {
    return is >> rhs;
}

#define var(type, ...) \
    type __VA_ARGS__;  \
    std::cin >> __VA_ARGS__
// }}}
endsnippet

snippet all-macro "Util/all-macro.hpp"
// all-macro {{{
#define all(x) std::begin(x), std::end(x)
#define rall(x) std::rbegin(x), std::rend(x)
// }}}
endsnippet

snippet chminmax "Util/chminmax.hpp"
// chminmax {{{
template <class T, class U>
inline bool chmin(T& a, const U& b) {
    return b < a && (a = b, true);
}

template <class T, class U>
inline bool chmax(T& a, const U& b) {
    return b > a && (a = b, true);
}
// }}}
endsnippet

snippet constexpr-randint "Util/constexpr-randint.hpp"
// constexpr-randint {{{
#define STRINGIZE_I(x) #x
#define STRINGIZE(x) STRINGIZE_I(x)
#define UNIQUE_STRING __DATE__ "_" __TIME__ "_" __FILE__ "_" STRINGIZE(__LINE__)

constexpr std::uint32_t constexprRandint(std::uint32_t min, std::uint32_t max) {
    const auto m = max - min + 1;
    return cstringHash(UNIQUE_STRING) % m + min;
}
// }}}
endsnippet

snippet cstring-hash "Util/cstring-hash.hpp"
// cstring-hash {{{
constexpr std::uint32_t cstringHash(const char* s) {
    std::uint32_t hashv = 0;
    while (*s != '\0') {
        hashv += *s++;
        hashv += hashv << 10;
        hashv ^= hashv >> 6;
    }
    hashv += hashv << 3;
    hashv ^= hashv >> 11;
    hashv += hashv << 15;
    return hashv;
}
// }}}
endsnippet

snippet int-alias "Util/int-alias.hpp"
// int-alias {{{
using i64 = std::int64_t;
using u64 = std::uint64_t;
// }}}
endsnippet

snippet int-infinity "Util/int-infinity.hpp"
// int-infinity {{{
constexpr std::int32_t INF = 0x3f3f3f3f;
constexpr std::int64_t LINF = 0x3f3f3f3f3f3f3f3fLL;
// }}}
endsnippet

snippet is-within-range "Util/is-within-range.hpp"
// is-within-range {{{
template <class Value, class ValueBegin, class ValueEnd>
inline bool within(const Value& v, const ValueBegin& begin, const ValueEnd& end) {
    return begin <= v && v < end;
}
// }}}
endsnippet

snippet makeVec "Util/makeVec.hpp"
// makeVec {{{
template <class T>
inline std::vector<T> makeVec(const T& initValue, size_t sz) {
    return std::vector<T>(sz, initValue);
}
template <class T, class... Args>
inline auto makeVec(const T& initValue, size_t sz, Args... args) {
    return std::vector<decltype(makeVec<T>(initValue, args...))>(sz, makeVec<T>(initValue, args...));
}
// }}}
endsnippet

snippet project "Util/project.hpp"
// project {{{
template <std::size_t I, class Container, class Value = typename std::tuple_element_t<I, typename Container::value_type>>
std::vector<Value> project(const Container& v) {
    std::vector<Value> ret(v.size());
    std::transform(v.begin(), v.end(), ret.begin(), [](auto&& t) { return std::get<I>(t); });
    return ret;
}
// }}}
endsnippet

snippet randoms "Util/randoms.hpp"
// randoms {{{
namespace arumakan::random {

std::mt19937 mt(std::random_device{}());

// 閉区間[min, max] の乱数を一様分布で生成する
template <class Integer>
Integer randint(Integer min, Integer max) {
    return std::uniform_int_distribution<Integer>(min, max)(mt);
}

// dest に randint(sizeMin, sizeMax) 回 randint(valueMin, valueMax) を格納する
template <class OutputIter, class Integer>
OutputIter randomValueContainer(OutputIter dest, Integer valueMin, Integer valueMax, std::size_t sizeMin, std::size_t sizeMax) {
    auto size = randint(sizeMin, sizeMax);
    while (size--) {
        *dest = randint(valueMin, valueMax);
        ++dest;
    }
    return dest;
}

// 要素数が randint(sizeMin, sizeMax) の randint(valueMin, valueMax) を生成する
template <class Container, class Integer>
Container randomValueContainer(Integer valueMin, Integer valueMax, std::size_t sizeMin, std::size_t sizeMax) {
    Container ret;
    randomValueContainer(std::back_inserter(ret), valueMin, valueMax, sizeMin, sizeMax);
    return ret;
}

// [begin, end) の範囲のうちひとつをランダムに選んで返す
template <class RandomAccessIter>
auto choice(RandomAccessIter begin, RandomAccessIter end) {
    const auto i = randint<std::size_t>(0, std::distance(begin, end));
    return begin[i];
}

}  // namespace rand
// }}}
endsnippet

snippet rep-macro "Util/rep-macro.hpp"
// rep-macro {{{
#define rep(i, begin, end) for (std::make_signed_t<std::remove_cv_t<decltype(end)>> i = (begin), i##_end = (end); i < i##_end; ++i)
#define repc(i, begin, last) for (std::make_signed_t<std::remove_cv_t<decltype(last)>> i = (begin), i##_last = (last); i <= i##_last; ++i)
#define repr(i, begin, last) for (std::make_signed_t<std::remove_cv_t<decltype(begin)>> i = (begin), i##_last = (last); i >= i##_last; --i)
// }}}
endsnippet

snippet runlength "Util/runlength.hpp"
// runlength {{{
template <class Iterator>
auto runlength(Iterator const begin, Iterator const end) {
    std::vector<std::pair<Iterator, std::size_t>> ret;
    ret.reserve(std::distance(begin, end));

    for (auto itr = begin; itr != end;) {
        std::size_t cnt = 1;
        const auto head = itr++;
        while (itr != end && *itr == *head) ++itr, ++cnt;
        ret.emplace_back(head, cnt);
    }

    ret.shrink_to_fit();
    return ret;
}
// }}}
endsnippet

snippet zip "Util/zip.hpp"
// zip {{{
template <class T1, class T2>
std::vector<std::pair<T1, T2>> zip(const std::vector<T1>& v1, const std::vector<T2>& v2) {
    const auto sz = std::min(v1.size(), v2.size());
    std::vector<std::pair<T1, T2>> ret(sz);
    for (std::size_t i = 0; i < sz; ++i) ret[i] = std::make_pair(v1[i], v2[i]);
    return ret;
}

template <class T1, class T2, class T3>
std::vector<std::tuple<T1, T2, T3>> zip(const std::vector<T1>& v1, const std::vector<T2>& v2, const std::vector<T3>& v3) {
    const auto sz = std::min({v1.size(), v2.size(), v3.size()});
    std::vector<std::tuple<T1, T2, T3>> ret(sz);
    for (std::size_t i = 0; i < sz; ++i) ret[i] = std::make_tuple(v1[i], v2[i], v3[i]);
    return ret;
}
// }}}
endsnippet

