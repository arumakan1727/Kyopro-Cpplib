snippet doubling-pow "Algorithm/doubling-pow.hpp"
// doubling-pow {{{
/**
 * @brief doubling-pow() (繰り返し二乗法)
 */
template <class Integer>
constexpr Integer doublingPow(const Integer& n, const i64 expv) {
    Integer ret = 1, square = n;
    for (u64 p = std::abs(expv); p; p >>= 1) {
        if (p & 1) ret *= square;
        square *= square;
    }
    return (expv < 0) ? (1 / ret) : ret;
}
// }}}

snippet union-find "Disjoint-Set/union-find.hpp"
// union-find {{{
/**
 * @brief Union-Find (素集合データ構造)
 * @note path-compression + union-by-size
 */
class UnionFind {
private:
    int n;
    mutable std::vector<int> p;

public:
    UnionFind() = default;

    explicit UnionFind(int n_)
        : n(n_)
        , p(n_, -1) {}

    int unite(int x, int y) {
        x = leader(x), y = leader(y);
        if (x == y) return x;
        if (p[y] < p[x]) std::swap(x, y);
        p[x] += p[y];
        p[y] = x;
        return x;
    }

    int leader(int x) const { return p[x] < 0 ? x : p[x] = leader(p[x]); }

    bool same(int x, int y) const { return leader(x) == leader(y); }

    int size(int x) const { return -p[leader(x)]; }

    std::vector<std::vector<int>> groups() const {
        std::vector<int> leaderBuf(n), groupSize(n);
        for (int i = 0; i < n; i++) ++groupSize[leaderBuf[i] = leader(i)];

        std::vector<std::vector<int>> result(n);
        for (int i = 0; i < n; i++) result[i].reserve(groupSize[i]);
        for (int i = 0; i < n; i++) result[leaderBuf[i]].push_back(i);
        result.erase(std::remove_if(result.begin(), result.end(), [](const std::vector<int>& v) { return v.empty(); }), result.end());
        return result;
    }
};
// }}}

snippet FenwicTree "Range-Accumulate/FenwicTree.hpp"
// FenwicTree {{{
/**
 * @brief Fenwic-Tree (Binary-Indexed-Tree)
 */
template <class T>
class FenwicTree {
    size_t m_size;
    std::vector<T> dat;

public:
    FenwicTree() = default;

    explicit FenwicTree(size_t n)
        : m_size(n)
        , dat(n + 1) {}

    //! i: [0, n)
    void add(size_t i, const T& value) {
        assert(i < m_size);
        ++i;
        while (i <= m_size) dat[i] += value, i += i & -i;
    }

    //! [0, r)
    const T prefixSum(size_t r) const {
        T acc = 0;
        while (r > 0) acc += dat[r], r -= r & -r;
        return acc;
    }

    //! [l, r)
    const T sum(size_t l, size_t r) const { return prefixSum(r) - prefixSum(l); }

    //! i: [0, n)
    const T at(size_t i) const { return prefixSum(i + 1) - prefixSum(i); }

    //! return `i` s.t. prefixSum(i) >= value
    size_t lowerBound(T value) const {
        if (value <= 0) return 0;
        static const auto B = floorPow2(m_size);
        size_t i = 0;
        for (size_t k = B; k > 0; k >>= 1) {
            if (i + k <= m_size && dat[i + k] < value) {
                value -= dat[i + k];
                i += k;
            }
        }
        return i + 1;
    }

private:
    static inline constexpr size_t floorPow2(size_t x) noexcept {
        size_t ret = 1;
        while (ret <= x) ret <<= 1;
        return ret >> 1;
    }
};
// }}}

snippet cumulative-sum "Range-Accumulate/cumulative-sum.hpp"
// cumulative-sum {{{
/**
 * @brief CumulativeSum (累積和)
 */
template <class T>
struct CumulativeSum {
    std::valarray<T> data;

    CumulativeSum() = default;

    template <class Container>
    explicit CumulativeSum(const Container& container)
        : CumulativeSum(container.cbegin(), container.cend()) {}

    template <class InputItr>
    CumulativeSum(InputItr begin, InputItr end)
        : data(std::distance(begin, end) + 1) {
        size_t i;
        InputItr itr;
        for (i = 0, itr = begin; itr != end; ++i, ++itr) {
            data[i + 1] = data[i] + *itr;
        }
    }

    //! [0, r)
    const T prefixSum(size_t r) const { return data[r]; }

    //! [l, r)
    const T sum(size_t l, size_t r) const { return prefixSum(r) - prefixSum(l); }
};
// }}}

snippet foldLR "Range-Accumulate/foldLR.hpp"
// foldLR {{{
/**
 * @brief FoldLR
 */
template <class T>
class FoldLR {
    std::vector<T> m_foldL, m_foldR;
    T m_e;

public:
    FoldLR() = default;

    template <class BidirectionalItr, class Op>
    FoldLR(BidirectionalItr begin, BidirectionalItr end, const T& e, Op op)
        : FoldLR(begin, end, e, op, op) {}

    /**
     * foldLeftOp: (T, Elem) -> T
     * foldRightOp: (Elem, T) -> T
     */
    template <class BidirectionalItr, class FoldLeftOp, class FoldRightOp>
    FoldLR(BidirectionalItr begin, BidirectionalItr end, const T& e, FoldLeftOp foldLeftOp, FoldRightOp foldRightOp)
        : m_foldL(std::distance(begin, end) + 1, e)
        , m_foldR(std::distance(begin, end) + 1, e)
        , m_e(e) {
        size_t i;
        BidirectionalItr itr;
        for (i = 0, itr = begin; itr != end; ++i, ++itr) {
            m_foldL[i + 1] = foldLeftOp(m_foldL[i], *itr);
        }
        for (i = m_foldR.size() - 1, itr = std::prev(end); i > 0; --i, --itr) {
            m_foldR[i - 1] = foldRightOp(*itr, m_foldR[i]);
        }
    }

    /**
     * [0, r)
     * ((((e op a[0]) op a[1]) op a[2]) ... op a[r - 1])
     * foldL(0) returns e();
     */
    const T foldL(size_t r) const { return m_foldL[r]; }

    /**
     * [l, N)
     * (a[l] op ... (a[N - 3] op (a[N - 2] op (a[N - 1] op e))))
     * foldR(N) returns e();
     */
    const T foldR(size_t l) const { return m_foldR[l]; }

    const T e() const { return m_e; }
};
// }}}

snippet kruskal "Minimum-Spanning-Tree/kruskal.hpp"
// kruskal {{{
/**
 * @brief kruskal() (クラスカル法)
 */
template <class ResultType, class WeightType>
ResultType kruskal(int V, std::vector<Edge<WeightType>>& edges) {
    ResultType weightSum{};
    UnionFind uf(V);
    std::sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {
        return e1.weight < e2.weight;
    });
    for (const auto &e : edges) {
        if (uf.same(e.from, e.to)) continue;
        uf.unite(e.from, e.to);
        weightSum += e.weight;
    }
    return weightSum;
}
// }}}

snippet bfs "Shortest-Path/bfs.hpp"
// bfs {{{
/**
 * @brief bfs() (幅優先探索による単一始点最短経路, 次元拡張に対応)
 *
 * @param dist:
 *      start からの距離を格納する配列。
 *      要素数は頂点数以上でなければならない。-1やINFなど、距離として正当でない値でfillされている必要がある。
 *      多次元配列でもOK。
 *
 * @param start:
 *      頂点を表すdistの添字。
 *      distが一次元配列なら整数型,
 *      distが二次元配列ならstd::pair<integer, integer> または std::tuple<integer, integer> または std::array<integer, 2>,
 *      distが三次元配列ならstd::tuple<integer, integer, integer> または std::array<integer, 3>。
 *      start = {i, j, k} のとき dist[i][j][k] でアクセスする。
 *
 * @param enumerateNextVertex:
 *      fn(from: Vertex, fn(to: Vertex) => void) => void
 *      第一引数にVertex, 第二引数に関数をとる関数。
 *      この関数が第一引数の頂点fromから次の頂点の遷移先を列挙し、第二引数に渡すことで bfs() に遷移処理を委譲する。
 */
template <class DistArray, class Vertex, class NextVertexEnumerator>
DistArray bfs(DistArray&& dist, Vertex start, NextVertexEnumerator enumerateNextVertex) {
    using arumakan::at;
    assert(!dist.empty());
    assert(at(dist, start) == -1 || at(dist, start) >= INF);

    std::queue<Vertex> que({start});
    const auto yetReachedMarker = at(dist, start);
    at(dist, start) = 0;
    while (!que.empty()) {
        const Vertex v = std::move(que.front());
        que.pop();
        const auto curDist = at(dist, v);
        enumerateNextVertex(v, [&](Vertex nxt) {
            if (at(dist, nxt) == yetReachedMarker) {
                at(dist, nxt) = curDist + 1;
                que.push(nxt);
            }
        });
    }
    return dist;
}
// }}}

snippet dijkstra "Shortest-Path/dijkstra.hpp"
// dijkstra {{{
/**
 * @brief dijkstra() (ダイクストラ, $O((V + E)\log V)$)
 *
 * @param dist:
 *      start からの距離を格納する配列。
 *      要素数は頂点数以上でなければならない。INFなどのでかい値でfillされている必要がある。
 *      多次元配列でもOK。
 *
 * @param start:
 *      頂点を表すdistの添字。
 *      distが一次元配列なら整数型,
 *      distが二次元配列ならstd::pair<integer, integer> または std::tuple<integer, integer> または std::array<integer, 2>,
 *      distが三次元配列ならstd::tuple<integer, integer, integer> または std::array<integer, 3>。
 *      start = {i, j, k} のとき dist[i][j][k] でアクセスする。
 *
 * @param enumerateNextVertex:
 *      fn(from: Vertex, fn(to: Vertex, w: EdgeWeight) => void) => void
 *      第一引数にVertex, 第二引数に関数をとる関数。
 *      この関数が第一引数の頂点fromから次の頂点の遷移先を列挙し、第二引数に渡すことで dijkstra() に遷移処理を委譲する。
 */
template <class DistArray, class Vertex, class NextVertexEnumerator>
DistArray dijkstra(DistArray&& dist, Vertex start, NextVertexEnumerator enumerateNextVertex) {
    using arumakan::at;
    assert(!dist.empty());
    assert(at(dist, start) >= INF);
    using WeightType = typename std::remove_reference_t<decltype(at(dist, start))>;
    using P = std::pair<WeightType, Vertex>;

    std::priority_queue<P, std::vector<P>, std::greater<P>> que;
    que.emplace(at(dist, start) = WeightType(), start);

    while (!que.empty()) {
        const auto curDist = que.top().first;
        const auto curVertex = que.top().second;
        que.pop();
        if (at(dist, curVertex) < curDist) continue;
        enumerateNextVertex(curVertex, [&](auto nxtVertex, auto edgeWeight) {
            if (chmin(at(dist, nxtVertex), curDist + edgeWeight)) {
                que.emplace(curDist + edgeWeight, nxtVertex);
            }
        });
    }
    return dist;
}

// }}}

snippet graph-template "Graph/graph-template.hpp"
// graph-template {{{
/**
 * @brief graph-template (Edge, Graph, MatrixGraph)
 */
//! グラフの辺 (重み付き)
template <class T>
struct Edge {
    int from, to;
    T weight;
    int id;

    Edge() = default;

    constexpr explicit Edge(int to_, const T& weight_)
        : Edge(-1, to_, weight_, -1) {}

    constexpr Edge(int from_, int to_, const T& weight_, int id_ = -1)
        : from(from_)
        , to(to_)
        , weight(weight_)
        , id(id_) {}

    constexpr const Edge rev() const { return Edge(to, from, weight, id); }

    template <class Int, std::enable_if_t<std::is_integral<Int>::value, std::nullptr_t> = nullptr>
    constexpr operator Int() const {
        return static_cast<Int>(to);
    }

    friend std::istream& operator>>(std::istream& is, Edge& e) { return is >> e.from >> e.to >> e.weight; }
};

//! グラフの辺 (重みなし)
template <>
struct Edge<void> {
    int from, to;
    int id;

    Edge() = default;

    constexpr explicit Edge(int to_)
        : Edge(-1, to_, -1) {}

    constexpr Edge(int from_, int to_, int id_ = -1)
        : from(from_)
        , to(to_)
        , id(id_) {}

    constexpr const Edge rev() const { return Edge(to, from, id); }

    template <class Int, std::enable_if_t<std::is_integral<Int>::value, std::nullptr_t> = nullptr>
    constexpr operator Int() const {
        return static_cast<Int>(to);
    }

    friend std::istream& operator>>(std::istream& is, Edge& e) { return is >> e.from >> e.to; }
};

template <class T>
using Graph = std::vector<std::vector<Edge<T>>>;
// }}}

snippet factorials "Combinatorics/factorials.hpp"
// factorials {{{
/**
 * @brief factorials (階乗, 階乗の逆元, nCr, nPr)
 */
template <class Mint>
struct Factorials {
public:
    using value_type = Mint;
    static constexpr size_t MAX_N = std::min<size_t>(1e7, Mint::mod()) + 1;

private:
    mutable std::vector<value_type> m_fact, m_finv;

public:
    Factorials() {
        m_fact.reserve(MAX_N);
        m_finv.reserve(MAX_N);
        m_fact.resize(2, value_type::raw(1));   // m_fact[0] = m_fact[1] = 1
        m_finv.resize(2, value_type::raw(1));   // m_finv[0] = m_finv[1] = 1
    }

    void preCalc(size_t n) const {
        if (n < m_fact.size()) return;
        const size_t l = m_fact.size();
        const size_t r = n + 1;
        m_fact.resize(r), m_finv.resize(r);
        for (size_t i = l; i < r; ++i) m_fact[i] = m_fact[i - 1] * i;
        m_finv[r - 1] = m_fact[r - 1].inv();
        for (size_t i = r - 1; i > l; --i) m_finv[i - 1] = m_finv[i] * i;
    }

    const value_type fact(int i) const { return preCalc(i), m_fact[i]; }
    const value_type finv(int i) const { return preCalc(i), m_finv[i]; }

    const value_type C(int n, int r) const {
        if (r < 0 || n < r) return value_type::raw(0);
        return preCalc(n), m_fact[n] * m_finv[r] * m_finv[n - r];
    }

    const value_type P(int n, int r) const {
        if (r < 0 || n < r) return value_type::raw(0);
        return preCalc(n), m_fact[n] * m_finv[n - r];
    }

    const value_type H(int n, int r) const {
        if (n < 0 || r < 0) return value_type::raw(0);
        if (n == 0 && r == 0) return value_type::raw(1);
        return C(n + r - 1, r);
    }
};
// }}}

snippet mersenne-prime-number-mod-int "Modulo/mersenne-prime-number-mod-int.hpp"
// mersenne-prime-number-mod-int {{{
/**
 * @brief MersennePrimeNumberModInt (法がメルセンヌ素数のModInt特殊化)
 */
namespace internal {

template <class ModHolder>
class ModInt;

constexpr int exponentOfMersennePrimeNumber(uint_fast64_t x) {
    if (x == (1ull << 61) - 1) return 61;
    if (x == (1ull << 31) - 1) return 31;
    if (x == (1ull << 19) - 1) return 19;
    if (x == (1ull << 17) - 1) return 17;
    if (x == (1ull << 13) - 1) return 13;
    if (x == (1ull << 7) - 1) return 7;
    if (x == (1ull << 5) - 1) return 5;
    if (x == (1ull << 3) - 1) return 3;
    if (x == (1ull << 2) - 1) return 2;
    return -1;
}

template <uint_fast64_t Mod>
struct MersennePrimeNumberModHolder {
    static constexpr uint_fast64_t mod = Mod;
    static constexpr uint32_t exp = exponentOfMersennePrimeNumber(Mod);
    static_assert(exponentOfMersennePrimeNumber(Mod) != -1, "Mod value is not a mersenne prime number.");
};

template <uint_fast64_t Mod>
class ModInt<MersennePrimeNumberModHolder<Mod>> {
private:
    using u64 = uint_fast64_t;
    using i64 = int_fast64_t;
    using largeUint = std::conditional < Mod<(1ull << 31), u64, __uint128_t>;
    using ModHolder = MersennePrimeNumberModHolder<Mod>;
    u64 value;

public:
    constexpr inline ModInt() noexcept
        : value(0) {}

    constexpr inline ModInt(i64 v) noexcept
        : value(ModInt::normalized(v)) {}

    static constexpr inline const ModInt raw(u64 v) noexcept {
        ModInt ret;
        ret.value = v;
        return ret;
    }

    static constexpr ModInt nullopt() noexcept { return ModInt::raw(Mod); }

    constexpr bool isNull() const noexcept { return *this == ModInt::nullopt(); }

    static constexpr inline u64 mod() noexcept { return ModHolder::mod; }

    template <class T>
    constexpr explicit operator T() const noexcept {
        return static_cast<T>(value);
    }

    constexpr u64 val() const noexcept { return value; }

    constexpr ModInt& operator+=(const ModInt& rhs) noexcept {
        if ((value += rhs.value) >= mod()) value -= mod();
        return *this;
    }
    constexpr ModInt& operator-=(const ModInt& rhs) noexcept {
        if (value < rhs.value) value += mod();
        value -= rhs.value;
        return *this;
    }
    constexpr ModInt& operator*=(const ModInt& rhs) noexcept {
        value = mul(value, rhs.value);
        return *this;
    }
    constexpr ModInt& operator/=(const ModInt& rhs) noexcept { return *this *= rhs.inv(); }
    constexpr const ModInt inv() const noexcept { return ModInt(ModInt::inverse(value, mod())); }
    constexpr const ModInt operator+() const noexcept { return *this; }
    constexpr const ModInt operator-() const noexcept { return ModInt(-static_cast<i64>(value)); }

    constexpr const ModInt pow(i64 expv) const noexcept {
        u64 ret = 1, square = value;
        for (u64 p = std::abs(expv); p; p >>= 1) {
            if (p & 1) ret = mul(ret, square);
            square = mul(square, square);
        }
        return (expv < 0) ? (ModInt::raw(1) / ModInt::raw(ret)) : ModInt::raw(ret);
    }

    friend constexpr bool operator==(const ModInt& lhs, const ModInt& rhs) noexcept { return lhs.value == rhs.value; }
    friend constexpr bool operator!=(const ModInt& lhs, const ModInt& rhs) noexcept { return lhs.value != rhs.value; }
    friend constexpr const ModInt operator+(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) += rhs; }
    friend constexpr const ModInt operator-(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) -= rhs; }
    friend constexpr const ModInt operator*(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) *= rhs; }
    friend constexpr const ModInt operator/(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) /= rhs; }

    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) {
#ifdef LOCAL_DEBUG
        if (x.isNull()) return os << "{nullopt}";
#endif
        return os << x.value;
    }

    friend std::istream& operator>>(std::istream& is, ModInt& x) {
        is >> x.value;
        x.value = ModInt::normalized(x.value);
        return is;
    }

private:
    static constexpr inline u64 applyMod_u64(u64 x) noexcept {
        x = (x >> ModHolder::exp) + (x & mod());
        if (x >= mod()) x -= mod();
        return x;
    }

    static constexpr inline u64 applyMod_largeUint(largeUint x) noexcept {
        u64 y = static_cast<u64>(x >> ModHolder::exp) + static_cast<u64>(x & mod());
        if (y >= mod()) y -= mod();
        return y;
    }

    static constexpr inline u64 mul(u64 a, u64 b) noexcept { return applyMod_largeUint(static_cast<largeUint>(a) * static_cast<largeUint>(b)); }

    static constexpr u64 normalized(i64 n) noexcept {
        if (n >= 0) return applyMod_u64(n);
        if (n < -mod()) n %= mod();
        return n += mod();
    }

    static constexpr i64 inverse(i64 a, i64 m) noexcept {
        i64 u = 0, v = 1;
        while (a != 0) {
            const auto t = m / a;
            static_cast<void>(m -= t * a), std::swap(m, a);
            static_cast<void>(u -= t * v), std::swap(u, v);
        }
        assert(m == 1);
        return u;
    }
};

}  // namespace internal

template <uint_fast64_t Mod>
using MersennePrimeNumberModInt = internal::ModInt<internal::MersennePrimeNumberModHolder<Mod>>;

using ModInt_2pow61_1 = MersennePrimeNumberModInt<(1ull << 61) - 1>;
// }}}

snippet mod-int "Modulo/mod-int.hpp"
// mod-int {{{
/**
 * @brief Mod-Int (コンパイル時mod型と実行時mod型)
 */
namespace internal {

template <class ModHolder>
class ModInt {
private:
    int64_t value;

public:
    constexpr ModInt() noexcept
        : value(0) {}

    constexpr ModInt(int64_t v) noexcept
        : value(ModInt::normalized(v)) {}

    static constexpr const ModInt raw(int64_t v) noexcept {
        ModInt ret;
        ret.value = v;
        return ret;
    }

    static constexpr ModInt nullopt() noexcept { return ModInt::raw(std::numeric_limits<int64_t>::min()); }

    constexpr bool isNull() const noexcept { return *this == ModInt::nullopt(); }

    static constexpr int64_t mod() { return ModHolder::mod; }

    static int64_t setMod(int64_t m) noexcept {
        assert(m >= 1);
        return ModHolder::mod = m;
    }

    template <class T>
    constexpr explicit operator T() const noexcept {
        return static_cast<T>(value);
    }

    constexpr int64_t val() const noexcept { return value; }

    constexpr ModInt& operator+=(const ModInt& rhs) noexcept {
        if ((value += rhs.value) >= mod()) value -= mod();
        return *this;
    }
    constexpr ModInt& operator-=(const ModInt& rhs) noexcept {
        if ((value -= rhs.value) < 0) value += mod();
        return *this;
    }
    constexpr ModInt& operator*=(const ModInt& rhs) noexcept {
        (value *= rhs.value) %= mod();
        return *this;
    }
    constexpr ModInt& operator/=(const ModInt& rhs) noexcept { return *this *= rhs.inv(); }
    constexpr const ModInt inv() const noexcept { return ModInt(ModInt::inverse(value, mod())); }
    constexpr const ModInt operator+() const noexcept { return *this; }
    constexpr const ModInt operator-() const noexcept { return ModInt(-value); }

    constexpr const ModInt pow(int64_t expv) const noexcept {
        int64_t ret = 1, square = value;
        for (uint64_t p = std::abs(expv); p; p >>= 1) {
            if (p & 1) (ret *= square) %= mod();
            (square *= square) %= mod();
        }
        return (expv < 0) ? (ModInt::raw(1) / ModInt::raw(ret)) : ModInt::raw(ret);
    }

    friend constexpr bool operator==(const ModInt& lhs, const ModInt& rhs) noexcept { return lhs.value == rhs.value; }
    friend constexpr bool operator!=(const ModInt& lhs, const ModInt& rhs) noexcept { return lhs.value != rhs.value; }
    friend constexpr const ModInt operator+(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) += rhs; }
    friend constexpr const ModInt operator-(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) -= rhs; }
    friend constexpr const ModInt operator*(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) *= rhs; }
    friend constexpr const ModInt operator/(const ModInt& lhs, const ModInt& rhs) noexcept { return ModInt(lhs) /= rhs; }

    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) {
#ifdef LOCAL_DEBUG
        if (x.isNull()) return os << "{nullopt}";
#endif
        return os << x.value;
    }

    friend std::istream& operator>>(std::istream& is, ModInt& x) {
        is >> x.value;
        x.value = ModInt::normalized(x.value);
        return is;
    }

private:
    static constexpr int64_t normalized(int64_t n) {
        n = (-mod() <= n && n < mod() ? n : n % mod());
        if (n < 0) n += mod();
        return n;
    }

    static constexpr int64_t inverse(int64_t a, int64_t m) {
        int64_t u = 0, v = 1;
        while (a != 0) {
            const auto t = m / a;
            static_cast<void>(m -= t * a), std::swap(m, a);
            static_cast<void>(u -= t * v), std::swap(u, v);
        }
        assert(m == 1);
        return u;
    }
};

template <int64_t Mod>
struct StaticModHolder {
    static constexpr int64_t mod = Mod;
};

template <int ID>
struct DynamicModHolder {
    static int64_t mod;
};
template <int ID>
int64_t DynamicModHolder<ID>::mod;

}  // namespace internal

template <int64_t Mod>
using StaticModInt = internal::ModInt<internal::StaticModHolder<Mod>>;

using ModInt1000000007 = StaticModInt<int(1e9) + 7>;
using ModInt998244353 = StaticModInt<998244353>;

template <int ID>
using DynamicModInt = internal::ModInt<internal::DynamicModHolder<ID>>;
// }}}

snippet divisor-count-table "Number-Theory/divisor-count-table.hpp"
// divisor-count-table {{{
/**
 * @brief divisorCountTable (約数の個数のテーブル, $O(N \log N)$)
 * cnt[i] = i の約数の個数; 範囲は閉区間 [0, N]
 */
std::vector<int> divisorCountTable(int N) {
    std::vector<int> cnt(N + 1);
    for (int d = 1; d <= N; ++d) {
        for (int i = d; i <= N; i += d) ++cnt[i];
    }
    return cnt;
}
// }}}

snippet enumerate-divisors "Number-Theory/enumerate-divisors.hpp"
// enumerate-divisors {{{
/**
 * @brief enumerateDivisors() (約数列挙)
 */
template <class Integer>
std::vector<Integer> enumerateDivisors(Integer n) {
    std::vector<Integer> divisors;
    Integer i;
    for (i = 1; i * i < n; ++i) {
        if (n % i == 0) divisors.push_back(i), divisors.push_back(n / i);
    }
    if (i * i == n) divisors.push_back(i);
    std::sort(divisors.begin(), divisors.end());
    return divisors;
}
// }}}

snippet eratosthenes-sieve "Number-Theory/eratosthenes-sieve.hpp"
// eratosthenes-sieve {{{
/**
 * @brief Eratosthenes-Sieve (エラトステネスの篩)
 * @see https://qiita.com/rsk0315_h4x/items/ff3b542a4468679fb409
 */
class EratosthenesSieve {
private:
    int m_size;
    std::vector<int> m_minFactor;

public:
    EratosthenesSieve() = default;

    //! [0, n] の範囲で篩を構築する
    explicit EratosthenesSieve(int n_)
        : m_size(n_ + 1)
        , m_minFactor(m_size) {
        std::iota(m_minFactor.begin(), m_minFactor.end(), 0);
        for (int i = 2; i * i < m_size; ++i) {
            if (m_minFactor[i] < i) continue;
            for (int j = i * i; j < m_size; j += i) {
                if (m_minFactor[j] == j) m_minFactor[j] = i;
            }
        }
        m_minFactor[0] = -1;
        if (n_ >= 1) m_minFactor[1] = -1;
    }

    bool isPrime(int x) const {
        assert(0 <= x && x < m_size);
        return m_minFactor[x] == x;
    }

    int minFactor(int x) const {
        assert(0 <= x && x < m_size);
        return m_minFactor[x];
    }
};
// }}}

snippet extgcd "Number-Theory/extgcd.hpp"
// extgcd {{{
/**
 * @brief extgcd() (拡張ユークリッドの互除法)
 * ax + by = gcd(a, b) の整数解 (x, y) を引数に格納する
 */
template <class T>
T extgcd(T a, T b, T& x, T& y) {
    T g = a;
    if (b != 0) {
        g = extgcd(b, a % b, y, x);
        y -= (a / b) * x;
    } else {
        x = 1;
        y = 0;
    }
    return g;
}
// }}}

snippet is-prime "Number-Theory/is-prime.hpp"
// is-prime {{{
/**
 * @brief isPrime() (素数判定 $O(\sqrt n)$)
 */
constexpr bool isPrime(int64_t n) {
    if (n == 2) return true;
    if (n <= 1 || n % 2 == 0) return false;
    for (int64_t i = 3; i * i <= n; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}
// }}}

snippet osa_k "Number-Theory/osa_k.hpp"
// osa_k {{{
/**
 * @brief osa_k() (前計算 $O(N \log \log N)$, 素因数分解 $O(\log N)$)
 * @see https://qiita.com/rsk0315_h4x/items/ff3b542a4468679fb409
 */
std::map<int, int> osa_k(int n, const EratosthenesSieve& es) {
    std::map<int, int> ret;
    while (n > 1) {
        ++ret[es.minFactor(n)];
        n /= es.minFactor(n);
    }
    return ret;
}
// }}}

snippet prime-factorize "Number-Theory/prime-factorize.hpp"
// prime-factorize {{{
/**
 * @brief primeFactorize() (素因数分解 $O(\sqrt n)$)
 */
template <class Integer>
std::map<Integer, int> primeFactorize(Integer n) {
    std::map<Integer, int> res;
    for (Integer i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            ++res[i];
            n /= i;
        }
    }
    if (n != 1) res[n] = 1;
    return res;
}
// }}}

snippet totient-func "Number-Theory/totient-func.hpp"
// totient-func {{{
/**
 * @brief totient() (オイラーのトーシェント関数)
 */
template <class Integer>
constexpr Integer totient(Integer n) {
    Integer ret = n;
    for (Integer i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            ret -= ret / i;
            while (n % i == 0) n /= i;
        }
    }
    if (n != 1) ret -= ret / n;
    return ret;
}
// }}}

snippet rabin-karp "String/rabin-karp.hpp"
// rabin-karp {{{
/**
 * @brief rabinKarp() (ラビンカープ法, RollingHashを用いた文字列検索 $O(|s|)$)
 * s の中で pattern が出現するインデックスを全て求めて vector として返す(インデックスは昇順)。
 */
template <uint_fast64_t Base>
std::vector<size_t> rabinKarp(const RollingHash<Base>& s, const RollingHash<Base>& pattern) {
    const auto sLen = s.size();
    const auto patLen = pattern.size();

    std::vector<size_t> foundIndexes;
    foundIndexes.reserve(sLen);

    for (size_t i = 0; i + patLen <= sLen; ++i) {
        if (s.substr(i, patLen) == pattern.hash()) foundIndexes.emplace_back(i);
    }

    foundIndexes.shrink_to_fit();
    return foundIndexes;
}
// }}}

snippet rolling-hash "String/rolling-hash.hpp"
// rolling-hash {{{
/**
 * @brief Rolling-Hash (ローリングハッシュ, mod値 $2^{61} - 1$ 固定)
 * @see https://qiita.com/keymoon/items/11fac5627672a6d6a9f6
 */
template <uint_fast64_t Base>
class RollingHash {
public:
    using u64 = uint_fast64_t;
    using u128 = __uint128_t;
    static constexpr u64 MOD = (1uL << 61) - 1;
    static constexpr u64 BASE = Base;

private:
    std::vector<u64> m_hash;

public:
    RollingHash() = default;

    template <class InputIter>
    RollingHash(InputIter begin, InputIter end)
        : m_hash(std::distance(begin, end) + 1, 0) {
        if (powArray().empty()) {
            powArray().reserve(1e6);
            powArray().emplace_back(1);
        }
        growPowArray(m_hash.size());

        size_t i;
        InputIter itr;
        for (itr = begin, i = 0; itr != end; ++itr, ++i) {
            m_hash[i + 1] = add(mul(m_hash[i], BASE), *itr);
        }
    }

    //! 文字列全体のハッシュ値
    u64 hash() const { return m_hash.back(); }

    //! 半開区間 [l, r) のハッシュ値
    u64 rangeHash(size_t l, size_t r) const {
        assert(l < r && r < m_hash.size());
        return add(m_hash[r], MOD - mul(m_hash[l], powArray()[r - l]));
    }

    //! rangeHash(begin, begin + length) と等価
    u64 substr(size_t begin, size_t length) const { return rangeHash(begin, begin + length); }

    //! もとの文字列の長さ
    size_t size() const { return m_hash.size() - 1; }

    //! 連結した文字列 (leftStr + rightStr) のハッシュ値
    static u64 concat(u64 leftHash, u64 rightHash, size_t rightLength) {
        growPowArray(rightLength);
        return add(mul(leftHash, powArray()[rightLength]), rightHash);
    }

private:
    static inline std::vector<u64>& powArray() {
        static std::vector<u64> p;
        return p;
    }

    static constexpr inline u64 add(u64 a, u64 b) noexcept {
        if ((a += b) >= MOD) a -= MOD;
        return a;
    }

    static constexpr inline u64 mul(u128 a, u128 b) noexcept {
        const auto c = a * b;
        return add(static_cast<u64>(c >> 61), static_cast<u64>(c & MOD));
    }

    static inline void growPowArray(size_t len) {
        ++len;
        while (powArray().size() < len) {
            powArray().emplace_back(mul(powArray().back(), BASE));
        }
    }
};
// }}}

snippet debug "Debug/debug.hpp"
// debug {{{
/**
 * @brief Debug
 */
#ifdef LOCAL_DEBUG

namespace dbg {

int w_ = 4;
bool negativeValAsNull_ = true;
std::ostream* os = &std::cerr;

template <class T, std::enable_if_t<!std::is_arithmetic<T>::value, std::nullptr_t> = nullptr>
void put(const T& x) {
    *os << std::setw(w_) << x;
}
template <class T, std::enable_if_t<std::is_signed<T>::value, std::nullptr_t> = nullptr>
void put(const T& x) {
    if (x <= -INF)
        *os << std::setw(w_) << "-INF";
    else if (negativeValAsNull_ && x < 0)
        *os << std::setw(w_) << " - ";
    else if (x >= INF)
        *os << std::setw(w_) << "INF";
    else
        *os << std::setw(w_) << x;
}
template <class T, std::enable_if_t<std::is_unsigned<T>::value, std::nullptr_t> = nullptr>
void put(const T& x) {
    if (static_cast<int64_t>(x) >= static_cast<int64_t>(INF))
        *os << std::setw(w_) << "INF";
    else
        *os << std::setw(w_) << x;
}
template <class A, class B>
void put(const std::pair<A, B>& t) {
    *os << '(' << std::setw(w_) << std::get<0>(t) << ",  " << std::setw(w_) << std::get<1>(t) << ')';
}
template <class A, class B, class C>
void put(const std::tuple<A, B, C>& t) {
    *os << '(' << std::setw(w_) << std::get<0>(t) << ",  " << std::setw(w_) << std::get<1>(t) << ",  " << std::setw(w_) << std::get<2>(t) << ')';
}

template <class Arr>
void showArrayH__(const Arr& a, size_t begin, size_t end) {
    for (size_t i = begin; i < end; ++i) *os << '[' << std::setw(dbg::w_) << i << "] ";
    *os << '\n';
    for (size_t i = begin; i < end; ++i) *os << ' ', dbg::put(a[i]), *os << "  ";
    *os << '\n';
}
template <class Arr>
void showArrayV__(const Arr& a, size_t begin, size_t end) {
    for (size_t i = begin; i < end; ++i)
        *os << '[' << std::setw(2) << i << ']', dbg::put(a[i]), *os << "\n";
    *os << std::flush;
}
template <class Table>
void showTable__(const Table& t, size_t yBegin, size_t yEnd, size_t xBegin, size_t xEnd) {
    *os << std::string(1 + 2 + 1, ' ');
    for (size_t j = xBegin; j < xEnd; ++j) *os << '[' << std::setw(dbg::w_) << j << "] ";
    *os << '\n';

    for (size_t i = yBegin; i < yEnd; ++i) {
        *os << '[' << std::setw(2) << i << "]";
        for (size_t j = xBegin; j < xEnd; ++j) *os << ' ', dbg::put(t[i][j]), *os << "  ";
        *os << '\n';
    }
}

}  // namespace dbg

void debug_setw(int w) {
    dbg::w_ = w;
}
void debug_negativeValAsNull(bool f) {
    dbg::negativeValAsNull_ = f;
}
void debug_setOstream(std::ostream& os) {
    dbg::os = &os;
}
void debug_hr() {
    *dbg::os << "----------------------------------------------------------------------\n";
}
void debug_println() {
    *dbg::os << std::endl;
}
template <class Head, class... Tail>
void debug_println(const Head& head, const Tail&... tail) {
    dbg::put(head);
    debug_println(tail...);
}

#define putDbgPrefix() *dbg::os << __func__ << '(' << std::setfill('0') << std::setw(3) << __LINE__ << std::setfill(' ') << "): "
#define showArrayH(a, beginIdx, endIdx) (void)(putDbgPrefix() << #a << ":\n"), dbg::showArrayH__(a, beginIdx, endIdx)
#define showArrayV(a, beginIdx, endIdx) (void)(putDbgPrefix() << #a << ":\n"), dbg::showArrayV__(a, beginIdx, endIdx)
#define showTable(t, yBegin, yEnd, xBegin, xEnd) (void)(putDbgPrefix() << #t << ":\n"), dbg::showTable__(t, yBegin, yEnd, xBegin, xEnd)
#define dbgMsg_(x) "  |  " #x " = ", x
#define dump1(a) (void)(putDbgPrefix()), debug_println(#a " = ", a)
#define dump2(a, b) (void)(putDbgPrefix()), debug_println(#a " = ", a, dbgMsg_(b))
#define dump3(a, b, c) (void)(putDbgPrefix()), debug_println(#a " = ", a, dbgMsg_(b), dbgMsg_(c))
#define dump4(a, b, c, d) (void)(putDbgPrefix()), debug_println(#a " = ", a, dbgMsg_(b), dbgMsg_(c), dbgMsg_(d))
#define dump5(a, b, c, d, e) (void)(putDbgPrefix()), debug_println(#a " = ", a, dbgMsg_(b), dbgMsg_(c), dbgMsg_(d), dbgMsg_(e))
#define dump6(a, b, c, d, e, f) (void)(putDbgPrefix()), debug_println(#a " = ", a, dbgMsg_(b), dbgMsg_(c), dbgMsg_(d), dbgMsg_(e), dbgMsg_(f))
#define dump7(a, b, c, d, e, f, g) (void)(putDbgPrefix()), debug_println(#a " = ", a, dbgMsg_(b), dbgMsg_(c), dbgMsg_(d), dbgMsg_(e), dbgMsg_(f), dbgMsg_(g))
#define GET_8TH_ARG(dummy1, dummy2, dummy3, dummy4, dummy5, dummy6, dumy7, NAME, ...) NAME
#define dump(...) GET_8TH_ARG(__VA_ARGS__, dump7, dump6, dump5, dump4, dump3, dump2, dump1)(__VA_ARGS__)

#else

#define debug_setw(...) ((void)0)
#define debug_negativeValAsNull(...) ((void)0)
#define debug_setOstream(...) ((void)0)
#define debug_hr(...) ((void)0)
#define debug_println(...) ((void)0)
#define showArrayH(...) ((void)0)
#define showArrayV(...) ((void)0)
#define showTable(...) ((void)0)
#define dump(...) ((void)0)

#endif
// }}}

snippet errln "Debug/errln.hpp"
// errln {{{
/**
 * @brief errln() (println()のstderr版, デバッグ時のみ有効)
 */
inline void eprintln() {
    std::clog << std::endl;
}
template <class Head, class... Tail>
inline void eprintln(Head&& head, Tail&&... tail) {
    std::clog << head << &" "[!sizeof...(tail)];
    eprintln(std::forward<Tail>(tail)...);
}

#ifdef LOCAL_DEBUG
#define errln(...) std::clog << __FILE__ << "(" << __LINE__ << ")[" << __func__ << "()]: ", eprintln(__VA_ARGS__)
#else
#define errln(...) ((void)0)
#endif
// }}}

snippet graph-debug "Debug/graph-debug.hpp"
// graph-debug {{{
/**
 * @brief graph-debug (グラフのデバッグ出力)
 */
template <class T>
std::ostream& operator<<(std::ostream& os, const Edge<T>& e) {
    os << std::setw(0) << '(' << std::setfill('0') << std::setw(2) << e.from << "-" << std::setw(2) << e.to << ", w=" << std::setw(2) << e.weight;
    if (e.id != -1) os << ", id=" << std::setw(2) << e.id;
    os << std::setfill(' ') << ')';
    return os;
}

template<>
std::ostream& operator<<(std::ostream& os, const Edge<void>& e) {
    os << std::setw(0) << '(' << std::setfill('0') << std::setw(2) << e.from << "-" << std::setw(2) << e.to;
    if (e.id != -1) os << ", id=" << std::setw(2) << e.id;
    os << std::setfill(' ') << ')';
    return os;
}
// }}}

snippet container-input "IO/container-input.hpp"
// container-input {{{
/**
 * @brief std::istreamによるコンテナの入力
 */
template <class Container, class = typename Container::value_type, std::enable_if_t<!std::is_same<Container, std::string>::value, std::nullptr_t> = nullptr>
std::istream& operator>>(std::istream& is, Container& v) {
    for (auto& e : v) is >> e;
    return is;
}
// }}}

snippet container-output "IO/container-output.hpp"
// container-output {{{
/**
 * @brief std::ostreamによるコンテナの出力
 */
template <class Container, class = typename Container::value_type, std::enable_if_t<!std::is_same<Container, std::string>::value, std::nullptr_t> = nullptr>
std::ostream& operator<<(std::ostream& os, const Container& v) {
    for (auto it = std::begin(v); it != std::end(v); ++it) os << &" "[it == std::begin(v)] << *it;
    return os;
}
// }}}

snippet join-into-ostream "IO/join-into-ostream.hpp"
// join-into-ostream {{{
/**
 * @brief join() (要素を区切り文字で結合して出力)
 */
template <class InputItr>
void join(std::ostream& os, InputItr begin, InputItr end, const char* delim, const char* last = "\n") {
    const char* tmp[] = {delim, ""};
    for (auto it = begin; it != end; ++it) os << tmp[it == begin] << *it;
    os << last;
}
// }}}

snippet println "IO/println.hpp"
// println {{{
/**
 * @brief println() (可変個の値を空白区切りで出力して改行する)
 */
inline void println() {
    std::cout << '\n';
}
template <class Head, class... Tail>
inline void println(Head&& head, Tail&&... tail) {
    std::cout << head << &" "[!sizeof...(tail)];
    println(std::forward<Tail>(tail)...);
}
// }}}

snippet read-directed-graph "IO/read-directed-graph.hpp"
// read-directed-graph {{{
/**
 * @brief readDirectedGraph() (有向グラフの入力)
 */
template <class T>
Graph<T> readDirectedGraph(size_t V, size_t E, int padding = -1, std::istream& is = std::cin) {
    Graph<T> G(V);
    for (size_t i = 0; i < E; ++i) {
        Edge<T> e;
        is >> e;
        e.from += padding, e.to += padding;
        e.id = static_cast<int>(i);
        G[e.from].emplace_back(e);
    }
    return G;
}

// }}}

snippet read-undirected-graph "IO/read-undirected-graph.hpp"
// read-undirected-graph {{{
/**
 * @brief readUndirectedGraph() (無向グラフの入力)
 */
template <class T>
Graph<T> readUndirectedGraph(size_t V, size_t E, int padding = -1, std::istream& is = std::cin) {
    Graph<T> G(V);
    for (size_t i = 0; i < E; ++i) {
        Edge<T> e;
        is >> e;
        e.from += padding, e.to += padding;
        e.id = static_cast<int>(i);
        G[e.from].emplace_back(e);
        G[e.to].emplace_back(e.rev());
    }
    return G;
}
// }}}

snippet read "IO/read.hpp"
// read {{{
/**
 * @brief read() (n個入力してContainerに格納して返す)
 */
template <class T = int, template <class, class...> class Container = std::vector>
Container<T> read(size_t n) {
    Container<T> ret(n);
    for (auto& e : ret) std::cin >> e;
    return ret;
}
// }}}

snippet var-declaration-with-input "IO/var-declaration-with-input.hpp"
// var-declaration-with-input {{{
/**
 * @brief 複数変数宣言をして同時に入力もするやつ
 */
template <class T>
std::istream& operator,(std::istream& is, T& rhs) {
    return is >> rhs;
}

#define var(type, ...) \
    type __VA_ARGS__;  \
    std::cin >> __VA_ARGS__
// }}}

snippet all-macro "Util/all-macro.hpp"
// all-macro {{{
/**
 * @brief all()マクロ
 */
#define all(x) std::begin(x), std::end(x)
#define rall(x) std::rbegin(x), std::rend(x)
// }}}

snippet at "Util/at.hpp"
// at {{{
/**
 * @brief at() ()
 */
namespace arumakan {

//! at(a, i) returns a[i]
template <class Array, class Integer, std::enable_if_t<std::is_integral<Integer>::value, std::nullptr_t> = nullptr>
inline auto at(Array&& a, Integer i) -> decltype(a[0])& {
    return a[i];
}

//! at(a, Tuple{i}) returns a[i]
template <class Array, class Tuple, std::enable_if_t<std::tuple_size<Tuple>::value == 1, std::nullptr_t> = nullptr>
inline auto at(Array&& a, Tuple index) -> decltype(a[0])& {
    return a[std::get<0>(index)];
}

//! at(mat, Tuple{y, x}) returns mat[y][x]
template <class Matrix, class Tuple, std::enable_if_t<std::tuple_size<Tuple>::value == 2, std::nullptr_t> = nullptr>
inline auto at(Matrix&& mat, Tuple index) -> decltype(mat[0][0])& {
    return mat[std::get<0>(index)][std::get<1>(index)];
}

//! at(cube, Tuple{z, y, x}) returns cube[z][y][x]
template <class Cube, class Tuple, std::enable_if_t<std::tuple_size<Tuple>::value == 3, std::nullptr_t> = nullptr>
inline auto at(Cube&& cube, Tuple index) -> decltype(cube[0][0][0])& {
    return cube[std::get<0>(index)][std::get<1>(index)][std::get<2>(index)];
}

}  // namespace arumakan
// }}}

snippet chminmax "Util/chminmax.hpp"
// chminmax {{{
/**
 * @brief chmin(), chmax()
 */
template <class T, class U>
inline bool chmin(T& a, const U& b) {
    return b < a && (a = b, true);
}

template <class T, class U>
inline bool chmax(T& a, const U& b) {
    return b > a && (a = b, true);
}
// }}}

snippet constexpr-randint "Util/constexpr-randint.hpp"
// constexpr-randint {{{
/**
 * @brief constexprRandint() (コンパイル時乱数)
 * 呼び出す度に値が変わるわけではないので う笑
 */
#define STRINGIZE_I(x) #x
#define STRINGIZE(x) STRINGIZE_I(x)
#define UNIQUE_STRING __DATE__ "_" __TIME__ "_" __FILE__ "_" STRINGIZE(__LINE__)

constexpr uint32_t constexprRandint(uint32_t min, uint32_t max) {
    const auto m = max - min + 1;
    return cstringHash(UNIQUE_STRING) % m + min;
}
// }}}

snippet cstring-hash "Util/cstring-hash.hpp"
// cstring-hash {{{
/**
 * @brief cstringHash() ヌル文字終端された文字列から32bitハッシュ値を生成する(constexpr)
 * @see https://en.wikipedia.org/wiki/Jenkins_hash_function
 */
constexpr uint32_t cstringHash(const char* s) {
    uint32_t hashv = 0;
    while (*s != '\0') {
        hashv += *s++;
        hashv += hashv << 10;
        hashv ^= hashv >> 6;
    }
    hashv += hashv << 3;
    hashv ^= hashv >> 11;
    hashv += hashv << 15;
    return hashv;
}
// }}}

snippet fillContainer "Util/fillContainer.hpp"
// fillContainer {{{
/**
 * @brief fillContainer() (コンテナのfill)
 */
template <class T, class Container, class... ConstructorArgs, std::enable_if_t<std::is_same<Container, T>::value, std::nullptr_t> = nullptr>
inline void fillContainer(Container& container, ConstructorArgs&&... constructorArgs) {
    container = T(std::forward<ConstructorArgs>(constructorArgs)...);
}

template <class T, class Container, class... ConstructorArgs, std::enable_if_t<!std::is_same<Container, T>::value, std::nullptr_t> = nullptr>
inline void fillContainer(Container& container, ConstructorArgs&&... constructorArgs) {
    for (auto& e: container) fillContainer<T>(e, std::forward<ConstructorArgs>(constructorArgs)...);
}
// }}}

snippet fix-point "Util/fix-point.hpp"
// fix-point {{{
/**
 * @brief FixPoint (ラムダ式の再帰)
 *
 * (Ex) FixPoint([&](auto func, int n) -> int {...})(10);
 */
template <class F>
struct FixPoint : F {
    FixPoint(F&& f)
        : F(std::forward<F>(f)) {}

    template <class... Args>
    decltype(auto) operator()(Args&&... args) const {
        return F::operator()(*this, std::forward<Args>(args)...);
    }
};
// }}}

snippet indexing-wrapper "Util/indexing-wrapper.hpp"
// indexing-wrapper {{{
/**
 * @brief IndexingWrapper
 *
 * a.at(i [, j, k, ...]) をコンストラクタで受け取った関数オブジェクトの呼び出し indexConverter(i [, j, k, ...]) として呼び出す
 * indexConverter() は参照を返さなければならない
 */
template <class IndexConverterFunc>
struct IndexingWrapper {
    IndexConverterFunc indexConverter;

    IndexingWrapper(IndexConverterFunc indexConverter_)
        : indexConverter(indexConverter_) {}

    template <class... Args>
    auto&& at(Args&&... args) {
        return indexConverter(std::forward<Args>(args)...);
    }

    template <class... Args>
    const auto&& at(Args&&... args) const {
        return indexConverter(std::forward<Args>(args)...);
    }

    template <class Arg>
    auto&& operator[](Arg&& arg) {
        return indexConverter(std::forward<Arg>(arg));
    }

    template <class Arg>
    const auto&& operator[](Arg&& arg) const {
        return indexConverter(std::forward<Arg>(arg));
    }
};
// }}}

snippet int-alias "Util/int-alias.hpp"
// int-alias {{{
/**
 * @brief int-alias (整数型のエイリアス)
 */
using i64 = int64_t;
using u64 = uint64_t;
// }}}

snippet int-infinity "Util/int-infinity.hpp"
// int-infinity {{{
/**
 * @brief int-infinity (整数のデカイ値)
 * 2倍してもオーバーフローしない & memset()にも使える (需要ある？)
 */
constexpr int32_t INF = 0x3f3f3f3f;
constexpr int64_t LINF = 0x3f3f3f3f3f3f3f3fLL;
// }}}

snippet is-within-range "Util/is-within-range.hpp"
// is-within-range {{{
/**
 * @brief within() (半開区間内に含まれているかの判定)
 */
template <class Value, class ValueBegin, class ValueEnd>
inline bool within(const Value& v, const ValueBegin& begin, const ValueEnd& end) {
    return begin <= v && v < end;
}
// }}}

snippet make-four-neighbor-enumerator "Util/make-four-neighbor-enumerator.hpp"
// make-four-neighbor-enumerator {{{
/**
 * @brief makeFourNeighborEnumerator() (グリッドの四近傍(上下左右)の列挙) 
 *
 * handlerFunc: fn({sy, sx}, {ny, nx}, f)
 */
template <class HandlerFunc>
auto makeFourNeighborEnumerator(int H, int W, HandlerFunc handlerFunc) {
    return [H, W, handlerFunc](auto v, auto func) {
        using P = decltype(v);
        static constexpr int dy[]{0, 1, 0, -1};
        const auto y = std::get<0>(v);
        const auto x = std::get<1>(v);

        for (size_t q = 0; q < 4; ++q) {
            const auto ny = y + dy[q];
            const auto nx = x + dy[q ^ 1];
            if (0 <= ny && ny < H && 0 <= nx && nx < W) handlerFunc(P{y, x}, P{ny, nx}, func);
        }
    };
}
// }}}

snippet makeVec "Util/makeVec.hpp"
// makeVec {{{
/**
 * @brief makeVec() (多次元std::vectorの生成)
 */
template <class T>
inline std::vector<T> makeVec(size_t sz, const T& initValue) {
    return std::vector<T>(sz, initValue);
}
template <class T, class... Args>
inline auto makeVec(size_t sz, Args... args) {
    return std::vector<decltype(makeVec<T>(args...))>(sz, makeVec<T>(args...));
}
// }}}

snippet project "Util/project.hpp"
// project {{{
/**
 * @brief project() (タプルのコンテナの第 I 要素を抽出したvectorを返す)
 */
template <size_t I, class Container, class Value = typename std::tuple_element_t<I, typename Container::value_type>>
std::vector<Value> project(const Container& v) {
    std::vector<Value> ret(v.size());
    std::transform(v.begin(), v.end(), ret.begin(), [](auto&& t) { return std::get<I>(t); });
    return ret;
}
// }}}

snippet randoms "Util/randoms.hpp"
// randoms {{{
/**
 * @brief randoms (randint()とかchoice()とか)
 */
namespace arumakan::random {

std::mt19937 mt(std::random_device{}());

//! 閉区間[min, max] の乱数を一様分布で生成する
template <class Integer>
Integer randint(Integer min, Integer max) {
    return std::uniform_int_distribution<Integer>(min, max)(mt);
}

//! dest に randint(sizeMin, sizeMax) 回 randint(valueMin, valueMax) を格納する
template <class OutputIter, class Integer>
OutputIter randomValueContainer(OutputIter dest, Integer valueMin, Integer valueMax, size_t sizeMin, size_t sizeMax) {
    auto size = randint(sizeMin, sizeMax);
    while (size--) {
        *dest = randint(valueMin, valueMax);
        ++dest;
    }
    return dest;
}

//! 要素数が randint(sizeMin, sizeMax) の randint(valueMin, valueMax) を生成する
template <class Container, class Integer>
Container randomValueContainer(Integer valueMin, Integer valueMax, size_t sizeMin, size_t sizeMax) {
    Container ret;
    randomValueContainer(std::back_inserter(ret), valueMin, valueMax, sizeMin, sizeMax);
    return ret;
}

//! [begin, end) の範囲のうちひとつをランダムに選んで返す
template <class RandomAccessIter>
auto choice(RandomAccessIter begin, RandomAccessIter end) {
    const auto i = randint<size_t>(0, std::distance(begin, end));
    return begin[i];
}

}  // namespace rand
// }}}

snippet rep-macro "Util/rep-macro.hpp"
// rep-macro {{{
/**
 * @brief rep()マクロ
 */
#define rep(i, begin, end) for (int64_t i = (begin), i##_end = (end); i < i##_end; ++i)
#define repc(i, begin, last) for (int64_t i = (begin), i##_last = (last); i <= i##_last; ++i)
#define repr(i, begin, last) for (int64_t i = (begin), i##_last = (last); i >= i##_last; --i)
// }}}

snippet runlength "Util/runlength.hpp"
// runlength {{{
/**
 * @brief runlength() (ランレングス圧縮)
 * (かたまりの始まり位置イテレータ, かたまりの要素数) のpairのvectorを返す。
 */
template <class Iterator>
auto runlength(Iterator const begin, Iterator const end) {
    std::vector<std::pair<Iterator, size_t>> ret;
    ret.reserve(std::distance(begin, end));

    for (auto itr = begin; itr != end;) {
        size_t cnt = 1;
        const auto head = itr++;
        while (itr != end && *itr == *head) ++itr, ++cnt;
        ret.emplace_back(head, cnt);
    }

    ret.shrink_to_fit();
    return ret;
}
// }}}

snippet timer "Util/timer.hpp"
// timer {{{
/**
 * @brief Timer (実行時間計測)
 */
class Timer {
    std::chrono::system_clock::time_point m_start;

public:
    Timer() = default;

    inline void start() {
        m_start = std::chrono::system_clock::now();
    }

    inline uint64_t elapsedMilli() const {
        using namespace std::chrono;
        const auto end = system_clock::now();
        return duration_cast<milliseconds>(end - m_start).count();
    }
};
// }}}

snippet zip "Util/zip.hpp"
// zip {{{
/**
 * @brief zip() (n個のvectorからn要素のタプルのvectorを生成する)
 */
template <class T1, class T2>
std::vector<std::pair<T1, T2>> zip(const std::vector<T1>& v1, const std::vector<T2>& v2) {
    const auto sz = std::min(v1.size(), v2.size());
    std::vector<std::pair<T1, T2>> ret(sz);
    for (size_t i = 0; i < sz; ++i) ret[i] = std::make_pair(v1[i], v2[i]);
    return ret;
}

template <class T1, class T2, class T3>
std::vector<std::tuple<T1, T2, T3>> zip(const std::vector<T1>& v1, const std::vector<T2>& v2, const std::vector<T3>& v3) {
    const auto sz = std::min({v1.size(), v2.size(), v3.size()});
    std::vector<std::tuple<T1, T2, T3>> ret(sz);
    for (size_t i = 0; i < sz; ++i) ret[i] = std::make_tuple(v1[i], v2[i], v3[i]);
    return ret;
}
// }}}

